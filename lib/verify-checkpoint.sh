#!/bin/bash
################################################################################
# NWP Progressive Checkpoint Library
#
# Part of P51: AI-Powered Deep Verification (Phase 5)
#
# This library provides enhanced checkpoint management for progressive execution
# of AI verification scenarios. It allows runs to be interrupted and resumed,
# preserves test sites between runs, and tracks detailed progress.
#
# Key Features:
#   - Checkpoint creation and persistence
#   - Run resumption from any point
#   - Test site preservation
#   - Progress percentage tracking
#   - Run history management
#
# Source this file: source "$PROJECT_ROOT/lib/verify-checkpoint.sh"
#
# Reference:
#   - P51: AI-Powered Deep Verification
#   - docs/proposals/P51-ai-powered-verification.md
################################################################################

# Determine paths
CHECKPOINT_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CHECKPOINT_PROJECT_ROOT="${PROJECT_ROOT:-$(cd "$CHECKPOINT_LIB_DIR/.." && pwd)}"

# Make PROJECT_ROOT available if not set
PROJECT_ROOT="${PROJECT_ROOT:-$CHECKPOINT_PROJECT_ROOT}"

# Configuration
CHECKPOINT_DIR="${CHECKPOINT_DIR:-$CHECKPOINT_PROJECT_ROOT/.verification-checkpoints}"
CHECKPOINT_FILE="${CHECKPOINT_FILE:-$CHECKPOINT_PROJECT_ROOT/.verification-checkpoint.yml}"
CHECKPOINT_HISTORY_DIR="${CHECKPOINT_HISTORY_DIR:-$CHECKPOINT_DIR/history}"
CHECKPOINT_SITES_FILE="${CHECKPOINT_SITES_FILE:-$CHECKPOINT_DIR/preserved-sites.yml}"
CHECKPOINT_MAX_HISTORY="${CHECKPOINT_MAX_HISTORY:-10}"

# Total items count (from P51 spec)
CHECKPOINT_TOTAL_SCENARIOS=17
CHECKPOINT_TOTAL_ITEMS=471

################################################################################
# SECTION 1: Initialization
################################################################################

#######################################
# Initialize checkpoint system
#######################################
checkpoint_system_init() {
    mkdir -p "$CHECKPOINT_DIR"
    mkdir -p "$CHECKPOINT_HISTORY_DIR"

    # Initialize preserved sites file if not exists
    if [[ ! -f "$CHECKPOINT_SITES_FILE" ]]; then
        cat > "$CHECKPOINT_SITES_FILE" << 'EOF'
# Preserved Test Sites
# These sites are kept between verification runs for debugging and resumption
# DO NOT DELETE MANUALLY - use 'checkpoint_cleanup_sites' to clean up

preserved_sites: []
EOF
    fi
}

#######################################
# Check if yq is available
# Returns: 0 if available, 1 if not
#######################################
checkpoint_check_yq() {
    if ! command -v yq &>/dev/null; then
        echo "ERROR: yq is required for checkpoint management." >&2
        echo "Install Go yq: https://github.com/mikefarah/yq" >&2
        return 1
    fi
    return 0
}

################################################################################
# SECTION 2: Checkpoint Creation and Management
################################################################################

#######################################
# Create a new checkpoint
# Arguments:
#   $1 - Run ID (optional, auto-generates if not provided)
# Returns: Run ID
#######################################
checkpoint_create() {
    local run_id="${1:-$(checkpoint_generate_id)}"
    local timestamp
    timestamp=$(date -Iseconds)

    checkpoint_system_init

    cat > "$CHECKPOINT_FILE" << EOF
# AI Verification Checkpoint
# Generated by P51 verify-checkpoint.sh
# Run ID: $run_id
# DO NOT EDIT MANUALLY

checkpoint:
  run_id: "$run_id"
  version: "1.0"
  started_at: "$timestamp"
  last_updated: "$timestamp"
  status: "in_progress"

  progress:
    scenarios:
      total: $CHECKPOINT_TOTAL_SCENARIOS
      completed: 0
      in_progress: 0
      failed: 0
      skipped: 0
      remaining: $CHECKPOINT_TOTAL_SCENARIOS
    items:
      total: $CHECKPOINT_TOTAL_ITEMS
      verified: 0
      percentage: 0

  current:
    scenario_id: null
    scenario_name: null
    step_index: 0
    step_name: null
    started_at: null

  completed_scenarios: []

  failed_scenarios: []

  test_sites:
    created: []
    preserved: []
    to_cleanup: []

  findings:
    errors: []
    warnings: []
    fixes_applied: []

  metrics:
    total_duration_seconds: 0
    scenarios_per_minute: 0
    estimated_remaining_minutes: 0
EOF

    echo "$run_id"
}

#######################################
# Generate a unique run ID
# Outputs: Run ID string
#######################################
checkpoint_generate_id() {
    echo "ai-verify-$(date +%Y%m%d-%H%M%S)"
}

#######################################
# Check if a checkpoint exists
# Returns: 0 if exists, 1 if not
#######################################
checkpoint_exists() {
    [[ -f "$CHECKPOINT_FILE" ]] && checkpoint_check_yq
}

#######################################
# Get current checkpoint run ID
# Outputs: Run ID or empty string
#######################################
checkpoint_get_run_id() {
    if [[ -f "$CHECKPOINT_FILE" ]]; then
        yq -r '.checkpoint.run_id // empty' "$CHECKPOINT_FILE" 2>/dev/null
    fi
}

#######################################
# Get checkpoint status
# Outputs: Status string (in_progress, completed, failed, interrupted)
#######################################
checkpoint_get_status() {
    if [[ -f "$CHECKPOINT_FILE" ]]; then
        yq -r '.checkpoint.status // "unknown"' "$CHECKPOINT_FILE" 2>/dev/null
    else
        echo "none"
    fi
}

################################################################################
# SECTION 3: Progress Tracking
################################################################################

#######################################
# Update checkpoint with current scenario
# Arguments:
#   $1 - Scenario ID
#   $2 - Scenario name
#######################################
checkpoint_start_scenario() {
    local scenario_id="$1"
    local scenario_name="$2"
    local timestamp
    timestamp=$(date -Iseconds)

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    yq -i "
        .checkpoint.current.scenario_id = \"$scenario_id\" |
        .checkpoint.current.scenario_name = \"$scenario_name\" |
        .checkpoint.current.step_index = 0 |
        .checkpoint.current.step_name = \"Starting\" |
        .checkpoint.current.started_at = \"$timestamp\" |
        .checkpoint.progress.scenarios.in_progress = 1 |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"
}

#######################################
# Update current step
# Arguments:
#   $1 - Step index
#   $2 - Step name
#######################################
checkpoint_update_step() {
    local step_index="$1"
    local step_name="$2"
    local timestamp
    timestamp=$(date -Iseconds)

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    yq -i "
        .checkpoint.current.step_index = $step_index |
        .checkpoint.current.step_name = \"$step_name\" |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"
}

#######################################
# Mark scenario as completed
# Arguments:
#   $1 - Scenario ID
#   $2 - Status (passed/failed)
#   $3 - Duration in seconds
#   $4 - Items verified
#   $5 - Confidence percentage
#######################################
checkpoint_complete_scenario() {
    local scenario_id="$1"
    local status="$2"
    local duration="$3"
    local items="${4:-0}"
    local confidence="${5:-0}"
    local timestamp
    timestamp=$(date -Iseconds)

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    # Add to completed or failed list
    local target_list
    [[ "$status" == "passed" ]] && target_list="completed_scenarios" || target_list="failed_scenarios"

    yq -i "
        .checkpoint.$target_list += [{
            \"id\": \"$scenario_id\",
            \"status\": \"$status\",
            \"duration_seconds\": $duration,
            \"items_verified\": $items,
            \"confidence\": $confidence,
            \"completed_at\": \"$timestamp\"
        }]
    " "$CHECKPOINT_FILE"

    # Update progress
    checkpoint_recalculate_progress

    # Clear current
    yq -i "
        .checkpoint.current.scenario_id = null |
        .checkpoint.current.scenario_name = null |
        .checkpoint.current.step_index = 0 |
        .checkpoint.current.step_name = null |
        .checkpoint.current.started_at = null |
        .checkpoint.progress.scenarios.in_progress = 0 |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"
}

#######################################
# Recalculate progress percentages
#######################################
checkpoint_recalculate_progress() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local completed failed skipped remaining
    completed=$(yq '.checkpoint.completed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")
    failed=$(yq '.checkpoint.failed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")
    skipped=$(yq '.checkpoint.progress.scenarios.skipped // 0' "$CHECKPOINT_FILE" 2>/dev/null)
    remaining=$((CHECKPOINT_TOTAL_SCENARIOS - completed - failed - skipped))

    # Calculate items verified (use bash to handle empty array gracefully)
    local items_verified=0
    local items_arr
    items_arr=$(yq -r '.checkpoint.completed_scenarios[].items_verified' "$CHECKPOINT_FILE" 2>/dev/null)
    if [[ -n "$items_arr" ]]; then
        for item in $items_arr; do
            [[ "$item" =~ ^[0-9]+$ ]] && items_verified=$((items_verified + item))
        done
    fi

    # Calculate percentage
    local percentage
    if [[ $CHECKPOINT_TOTAL_ITEMS -gt 0 ]]; then
        percentage=$((items_verified * 100 / CHECKPOINT_TOTAL_ITEMS))
    else
        percentage=0
    fi

    # Calculate metrics
    local started_at now_epoch started_epoch duration scenarios_per_min est_remaining
    started_at=$(yq -r '.checkpoint.started_at' "$CHECKPOINT_FILE" 2>/dev/null)
    now_epoch=$(date +%s)

    if [[ -n "$started_at" ]]; then
        started_epoch=$(date -d "$started_at" +%s 2>/dev/null || echo "$now_epoch")
        duration=$((now_epoch - started_epoch))

        if [[ $duration -gt 0 && $completed -gt 0 ]]; then
            scenarios_per_min=$(echo "scale=2; $completed / ($duration / 60)" | bc 2>/dev/null || echo "0")
            if [[ $(echo "$scenarios_per_min > 0" | bc) -eq 1 ]]; then
                est_remaining=$(echo "scale=0; $remaining / $scenarios_per_min" | bc 2>/dev/null || echo "0")
            else
                est_remaining=0
            fi
        else
            scenarios_per_min=0
            est_remaining=0
        fi
    else
        duration=0
        scenarios_per_min=0
        est_remaining=0
    fi

    # Update checkpoint
    yq -i "
        .checkpoint.progress.scenarios.completed = $completed |
        .checkpoint.progress.scenarios.failed = $failed |
        .checkpoint.progress.scenarios.remaining = $remaining |
        .checkpoint.progress.items.verified = $items_verified |
        .checkpoint.progress.items.percentage = $percentage |
        .checkpoint.metrics.total_duration_seconds = $duration |
        .checkpoint.metrics.scenarios_per_minute = $scenarios_per_min |
        .checkpoint.metrics.estimated_remaining_minutes = $est_remaining
    " "$CHECKPOINT_FILE"
}

#######################################
# Get progress percentage
# Outputs: Percentage (0-100)
#######################################
checkpoint_get_progress() {
    if [[ -f "$CHECKPOINT_FILE" ]]; then
        yq '.checkpoint.progress.items.percentage // 0' "$CHECKPOINT_FILE" 2>/dev/null
    else
        echo "0"
    fi
}

#######################################
# Get list of completed scenario IDs
# Outputs: Space-separated list
#######################################
checkpoint_get_completed_ids() {
    if [[ -f "$CHECKPOINT_FILE" ]]; then
        yq -r '.checkpoint.completed_scenarios[].id // empty' "$CHECKPOINT_FILE" 2>/dev/null | tr '\n' ' '
    fi
}

################################################################################
# SECTION 4: Test Site Preservation
################################################################################

#######################################
# Register a test site for preservation
# Arguments:
#   $1 - Site name
#   $2 - Scenario ID that created it
#   $3 - Reason for preservation
#######################################
checkpoint_preserve_site() {
    local site_name="$1"
    local scenario_id="$2"
    local reason="${3:-Verification test site}"
    local timestamp
    timestamp=$(date -Iseconds)

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    # Add to checkpoint
    yq -i "
        .checkpoint.test_sites.preserved += [{
            \"name\": \"$site_name\",
            \"scenario_id\": \"$scenario_id\",
            \"reason\": \"$reason\",
            \"created_at\": \"$timestamp\"
        }]
    " "$CHECKPOINT_FILE"

    # Also add to global preserved sites list
    yq -i "
        .preserved_sites += [{
            \"name\": \"$site_name\",
            \"run_id\": \"$(checkpoint_get_run_id)\",
            \"scenario_id\": \"$scenario_id\",
            \"reason\": \"$reason\",
            \"created_at\": \"$timestamp\"
        }]
    " "$CHECKPOINT_SITES_FILE"

    echo "Site $site_name preserved for debugging"
}

#######################################
# Mark a site for cleanup
# Arguments:
#   $1 - Site name
#######################################
checkpoint_mark_for_cleanup() {
    local site_name="$1"

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    yq -i "
        .checkpoint.test_sites.to_cleanup += [\"$site_name\"]
    " "$CHECKPOINT_FILE"
}

#######################################
# Get list of preserved sites
# Outputs: Site names, one per line
#######################################
checkpoint_get_preserved_sites() {
    if [[ -f "$CHECKPOINT_FILE" ]]; then
        yq -r '.checkpoint.test_sites.preserved[].name // empty' "$CHECKPOINT_FILE" 2>/dev/null
    fi
}

#######################################
# Cleanup test sites marked for deletion
# Arguments:
#   $1 - Force (true/false) - cleanup even preserved sites
#######################################
checkpoint_cleanup_sites() {
    local force="${1:-false}"

    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    echo "Cleaning up test sites..."

    # Get sites to cleanup
    local sites_to_cleanup
    sites_to_cleanup=$(yq -r '.checkpoint.test_sites.to_cleanup[] // empty' "$CHECKPOINT_FILE" 2>/dev/null)

    for site in $sites_to_cleanup; do
        if [[ -d "$PROJECT_ROOT/sites/$site" ]]; then
            echo "  Removing: $site"
            ./pl delete "$site" --yes 2>/dev/null || rm -rf "$PROJECT_ROOT/sites/$site"
        fi
    done

    # Clear cleanup list
    yq -i '.checkpoint.test_sites.to_cleanup = []' "$CHECKPOINT_FILE"

    # If force, also clean preserved sites
    if [[ "$force" == "true" ]]; then
        local preserved_sites
        preserved_sites=$(checkpoint_get_preserved_sites)
        for site in $preserved_sites; do
            if [[ -d "$PROJECT_ROOT/sites/$site" ]]; then
                echo "  Removing preserved: $site"
                ./pl delete "$site" --yes 2>/dev/null || rm -rf "$PROJECT_ROOT/sites/$site"
            fi
        done
        yq -i '.checkpoint.test_sites.preserved = []' "$CHECKPOINT_FILE"
    fi

    echo "Cleanup complete"
}

################################################################################
# SECTION 5: Resume and Recovery
################################################################################

#######################################
# Check if a run can be resumed
# Returns: 0 if resumable, 1 if not
#######################################
checkpoint_can_resume() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local status
    status=$(checkpoint_get_status)

    case "$status" in
        in_progress|interrupted)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

#######################################
# Get resume information
# Outputs: JSON with resume details
#######################################
checkpoint_get_resume_info() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        echo '{"can_resume": false}'
        return
    fi

    local run_id status progress completed current_scenario
    run_id=$(checkpoint_get_run_id)
    status=$(checkpoint_get_status)
    progress=$(checkpoint_get_progress)
    completed=$(yq '.checkpoint.completed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")
    current_scenario=$(yq -r '.checkpoint.current.scenario_id // "none"' "$CHECKPOINT_FILE" 2>/dev/null)

    cat << EOF
{
    "can_resume": $(checkpoint_can_resume && echo "true" || echo "false"),
    "run_id": "$run_id",
    "status": "$status",
    "progress_percentage": $progress,
    "scenarios_completed": $completed,
    "scenarios_total": $CHECKPOINT_TOTAL_SCENARIOS,
    "current_scenario": "$current_scenario"
}
EOF
}

#######################################
# Prepare for resume
# Marks current scenario as interrupted if needed
#######################################
checkpoint_prepare_resume() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local timestamp
    timestamp=$(date -Iseconds)

    # If there was a scenario in progress, mark it as needing retry
    local current_scenario
    current_scenario=$(yq -r '.checkpoint.current.scenario_id // empty' "$CHECKPOINT_FILE" 2>/dev/null)

    if [[ -n "$current_scenario" ]]; then
        echo "Previous run was interrupted during scenario: $current_scenario"
        echo "This scenario will be re-run from the beginning"

        # Clear current scenario (it will be re-run)
        yq -i "
            .checkpoint.current.scenario_id = null |
            .checkpoint.current.scenario_name = null |
            .checkpoint.current.step_index = 0 |
            .checkpoint.current.step_name = null |
            .checkpoint.progress.scenarios.in_progress = 0
        " "$CHECKPOINT_FILE"
    fi

    # Update status
    yq -i "
        .checkpoint.status = \"in_progress\" |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"
}

#######################################
# Mark run as interrupted (e.g., on SIGINT)
#######################################
checkpoint_mark_interrupted() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local timestamp
    timestamp=$(date -Iseconds)

    yq -i "
        .checkpoint.status = \"interrupted\" |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"

    echo ""
    echo "Run interrupted. Resume later with --resume flag."
}

#######################################
# Mark run as completed
#######################################
checkpoint_mark_completed() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local timestamp
    timestamp=$(date -Iseconds)

    # Determine final status based on failures
    local failed_count
    failed_count=$(yq '.checkpoint.failed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")

    local final_status
    [[ $failed_count -gt 0 ]] && final_status="completed_with_failures" || final_status="completed"

    yq -i "
        .checkpoint.status = \"$final_status\" |
        .checkpoint.completed_at = \"$timestamp\" |
        .checkpoint.last_updated = \"$timestamp\"
    " "$CHECKPOINT_FILE"

    # Archive checkpoint to history
    checkpoint_archive
}

################################################################################
# SECTION 6: History Management
################################################################################

#######################################
# Archive current checkpoint to history
#######################################
checkpoint_archive() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        return 1
    fi

    local run_id
    run_id=$(checkpoint_get_run_id)

    cp "$CHECKPOINT_FILE" "$CHECKPOINT_HISTORY_DIR/${run_id}.yml"

    # Prune old history
    checkpoint_prune_history
}

#######################################
# Prune old checkpoint history
#######################################
checkpoint_prune_history() {
    local history_files
    history_files=$(ls -t "$CHECKPOINT_HISTORY_DIR"/*.yml 2>/dev/null | tail -n +$((CHECKPOINT_MAX_HISTORY + 1)))

    for file in $history_files; do
        rm -f "$file"
    done
}

#######################################
# List historical runs
# Outputs: List of previous run IDs and status
#######################################
checkpoint_list_history() {
    echo ""
    echo "Verification Run History"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    printf "%-30s %-15s %-10s %s\n" "RUN ID" "STATUS" "PROGRESS" "DATE"
    printf "%-30s %-15s %-10s %s\n" "──────────────────────────────" "─────────────" "────────" "────────────────────"

    for file in $(ls -t "$CHECKPOINT_HISTORY_DIR"/*.yml 2>/dev/null | head -$CHECKPOINT_MAX_HISTORY); do
        local run_id status progress date
        run_id=$(yq -r '.checkpoint.run_id // "unknown"' "$file" 2>/dev/null)
        status=$(yq -r '.checkpoint.status // "unknown"' "$file" 2>/dev/null)
        progress=$(yq '.checkpoint.progress.items.percentage // 0' "$file" 2>/dev/null)
        date=$(yq -r '.checkpoint.started_at // ""' "$file" 2>/dev/null | cut -c1-19)

        printf "%-30s %-15s %8s%% %s\n" "$run_id" "$status" "$progress" "$date"
    done

    echo ""
}

################################################################################
# SECTION 7: Display Functions
################################################################################

#######################################
# Display checkpoint summary
#######################################
checkpoint_display_summary() {
    if [[ ! -f "$CHECKPOINT_FILE" ]]; then
        echo "No checkpoint found"
        return 1
    fi

    local run_id status progress completed failed remaining
    local items_verified items_total duration est_remaining

    run_id=$(checkpoint_get_run_id)
    status=$(checkpoint_get_status)
    progress=$(checkpoint_get_progress)
    completed=$(yq '.checkpoint.completed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")
    failed=$(yq '.checkpoint.failed_scenarios | length' "$CHECKPOINT_FILE" 2>/dev/null || echo "0")
    remaining=$(yq '.checkpoint.progress.scenarios.remaining // 0' "$CHECKPOINT_FILE" 2>/dev/null)
    items_verified=$(yq '.checkpoint.progress.items.verified // 0' "$CHECKPOINT_FILE" 2>/dev/null)
    items_total=$CHECKPOINT_TOTAL_ITEMS
    duration=$(yq '.checkpoint.metrics.total_duration_seconds // 0' "$CHECKPOINT_FILE" 2>/dev/null)
    est_remaining=$(yq '.checkpoint.metrics.estimated_remaining_minutes // 0' "$CHECKPOINT_FILE" 2>/dev/null)

    # Format duration
    local duration_fmt
    if [[ $duration -gt 3600 ]]; then
        duration_fmt="$((duration / 3600))h $((duration % 3600 / 60))m"
    elif [[ $duration -gt 60 ]]; then
        duration_fmt="$((duration / 60))m $((duration % 60))s"
    else
        duration_fmt="${duration}s"
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "                    Verification Progress"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    echo "  Run ID:     $run_id"
    echo "  Status:     $status"
    echo ""
    echo "  Scenarios:  $completed/$CHECKPOINT_TOTAL_SCENARIOS completed"
    [[ $failed -gt 0 ]] && echo "              $failed failed"
    echo "              $remaining remaining"
    echo ""
    echo "  Items:      $items_verified/$items_total verified"
    echo ""

    # Progress bar
    local bar_width=40
    local filled=$((progress * bar_width / 100))
    local empty=$((bar_width - filled))
    printf "  Progress:   ["
    printf "%0.s█" $(seq 1 $filled 2>/dev/null)
    printf "%0.s░" $(seq 1 $empty 2>/dev/null)
    printf "] %d%%\n" "$progress"

    echo ""
    echo "  Duration:   $duration_fmt"
    [[ $est_remaining -gt 0 ]] && echo "  Est. remaining: ~${est_remaining}m"
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
}

#######################################
# Print checkpoint help
#######################################
checkpoint_help() {
    cat << 'EOF'
NWP Progressive Checkpoint Library (P51 Phase 5)

Checkpoint Management:
  checkpoint_create [RUN_ID]           Create new checkpoint
  checkpoint_exists                    Check if checkpoint exists
  checkpoint_get_run_id                Get current run ID
  checkpoint_get_status                Get checkpoint status

Progress Tracking:
  checkpoint_start_scenario ID NAME    Mark scenario as started
  checkpoint_update_step INDEX NAME    Update current step
  checkpoint_complete_scenario ...     Mark scenario completed
  checkpoint_get_progress              Get progress percentage
  checkpoint_get_completed_ids         List completed scenario IDs

Site Preservation:
  checkpoint_preserve_site SITE ...    Preserve a test site
  checkpoint_mark_for_cleanup SITE     Mark site for cleanup
  checkpoint_get_preserved_sites       List preserved sites
  checkpoint_cleanup_sites [FORCE]     Clean up test sites

Resume and Recovery:
  checkpoint_can_resume                Check if resumable
  checkpoint_get_resume_info           Get resume details
  checkpoint_prepare_resume            Prepare for resume
  checkpoint_mark_interrupted          Mark as interrupted
  checkpoint_mark_completed            Mark run as done

History:
  checkpoint_list_history              Show previous runs
  checkpoint_archive                   Archive current checkpoint

Display:
  checkpoint_display_summary           Show progress summary

Examples:
  # Start a new verification run
  run_id=$(checkpoint_create)

  # Track scenario execution
  checkpoint_start_scenario "S1" "Foundation Setup"
  checkpoint_update_step 1 "Check Docker"
  checkpoint_complete_scenario "S1" "passed" 120 12 98

  # Resume interrupted run
  if checkpoint_can_resume; then
      checkpoint_prepare_resume
  fi
EOF
}

# Export functions
export -f checkpoint_system_init checkpoint_check_yq
export -f checkpoint_create checkpoint_generate_id checkpoint_exists
export -f checkpoint_get_run_id checkpoint_get_status
export -f checkpoint_start_scenario checkpoint_update_step checkpoint_complete_scenario
export -f checkpoint_recalculate_progress checkpoint_get_progress checkpoint_get_completed_ids
export -f checkpoint_preserve_site checkpoint_mark_for_cleanup
export -f checkpoint_get_preserved_sites checkpoint_cleanup_sites
export -f checkpoint_can_resume checkpoint_get_resume_info
export -f checkpoint_prepare_resume checkpoint_mark_interrupted checkpoint_mark_completed
export -f checkpoint_archive checkpoint_prune_history checkpoint_list_history
export -f checkpoint_display_summary checkpoint_help
