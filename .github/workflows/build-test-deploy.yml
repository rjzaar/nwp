name: Build, Test, Deploy

on:
  push:
    branches: [main, develop, staging, production]
  pull_request:
    branches: [main, develop]
  schedule:
    # Nightly at 6 PM UTC (1 PM EST, 10 AM PST)
    - cron: '0 18 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: choice
        options:
          - staging
          - production
        default: staging
      enable_terminal:
        description: 'Enable terminal session for debugging'
        type: boolean
        default: false

env:
  SITE_NAME: ${{ github.event.repository.name }}
  PHP_VERSION: "8.3"

jobs:
  # Nightly database caching job
  # Runs on schedule to fetch and cache production database
  database-nightly:
    name: Cache Database (Nightly)
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Fetch and sanitize production database
        run: |
          # TODO: Implement fetch-db.sh script
          # This should download prod DB, sanitize sensitive data, and store in .data/
          if [ -f scripts/ci/fetch-db.sh ]; then
            ./scripts/ci/fetch-db.sh --sanitize
          else
            echo "fetch-db.sh not yet implemented, creating placeholder"
            mkdir -p .data
            touch .data/db.sql.gz
          fi

      - name: Save database cache
        uses: actions/cache/save@v4
        with:
          path: .data/db.sql.gz
          key: db-nightly-${{ github.run_id }}

  # Main build and test job
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [database-nightly]
    if: always() && (needs.database-nightly.result == 'success' || needs.database-nightly.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Restore database cache
        uses: actions/cache/restore@v4
        with:
          path: .data/db.sql.gz
          key: db-nightly-
          restore-keys: |
            db-nightly-
            db-

      - name: Setup DDEV
        uses: ddev/github-action-setup-ddev@v1
        with:
          autostart: false

      - name: Build and provision site
        run: |
          if [ -f scripts/ci/build.sh ]; then
            ./scripts/ci/build.sh
          else
            echo "build.sh not found, running basic DDEV setup"
            ddev start
            ddev composer install
          fi

      - name: Run test suite
        run: |
          if [ -f scripts/ci/test.sh ]; then
            ./scripts/ci/test.sh
          else
            echo "test.sh not yet implemented, running basic tests"
            mkdir -p .logs/{phpunit,coverage}

            # Run PHPUnit if available
            if ddev exec test -f vendor/bin/phpunit; then
              ddev exec vendor/bin/phpunit \
                --coverage-clover=.logs/coverage/clover.xml \
                --coverage-cobertura=.logs/coverage/cobertura.xml \
                --log-junit=.logs/phpunit/junit.xml \
                || echo "PHPUnit tests completed with warnings"
            fi

            # Check coverage threshold if available
            if [ -f scripts/ci/check-coverage.sh ] && [ -f .logs/coverage/clover.xml ]; then
              ./scripts/ci/check-coverage.sh 80 || echo "Coverage check completed"
            fi
          fi

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: .logs/
          retention-days: 30

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            .logs/coverage/
            .logs/phpunit/
          retention-days: 30

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always() && hashFiles('.logs/phpunit/junit.xml') != ''
        with:
          files: |
            .logs/phpunit/junit.xml
            .logs/behat/*.xml

      - name: Generate coverage badge
        if: always() && hashFiles('.logs/coverage/clover.xml') != ''
        run: |
          if [ -f .logs/coverage/clover.xml ]; then
            COVERAGE=$(grep -oP 'statements="(\d+)".*coveredstatements="(\d+)"' .logs/coverage/clover.xml | head -1 | \
              awk -F'"' '{printf "%.0f", ($4/$2)*100}' || echo "0")
            echo "Code coverage: ${COVERAGE}%"
            echo "COVERAGE=${COVERAGE}" >> $GITHUB_ENV
          fi

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://${{ env.SITE_NAME }}-stg.ddev.site
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      - name: Deploy to staging server
        run: |
          if [ -f dev2stg.sh ]; then
            # Use NWP's dev2stg.sh script with auto-confirm and essential tests
            ./dev2stg.sh -y --db-source=auto -t essential ${{ env.SITE_NAME }}
          else
            echo "dev2stg.sh not found, skipping staging deployment"
          fi

      - name: Run post-deployment health checks
        run: |
          echo "Running health checks on staging environment..."
          # TODO: Implement health check script
          # Example: curl -f https://${{ env.SITE_NAME }}-stg.example.com/health

      - name: Notify deployment status
        if: always()
        run: |
          if [ -f scripts/notify.sh ]; then
            STATUS=${{ job.status }}
            EVENT="deploy_${STATUS}"
            ./scripts/notify.sh \
              --event=$EVENT \
              --site=${{ env.SITE_NAME }} \
              --url=https://${{ env.SITE_NAME }}-stg.ddev.site
          fi

  # Deploy to production environment (requires manual approval)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production') &&
      github.event_name == 'push'
    environment:
      name: production
      url: ${{ secrets.PRODUCTION_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

      - name: Pre-deployment backup
        run: |
          echo "Creating pre-deployment backup..."
          # TODO: Trigger backup on production server
          # ssh prod-server "/usr/local/bin/nwp-backup.sh ${{ env.SITE_NAME }}"

      - name: Deploy to production server
        id: deploy
        run: |
          if [ -f stg2prod.sh ]; then
            # Use NWP's stg2prod.sh script with auto-confirm
            ./stg2prod.sh -y ${{ env.SITE_NAME }}
            echo "deploy_success=true" >> $GITHUB_OUTPUT
          else
            echo "stg2prod.sh not found, skipping production deployment"
            echo "deploy_success=false" >> $GITHUB_OUTPUT
          fi

      - name: Run post-deployment health checks
        if: steps.deploy.outputs.deploy_success == 'true'
        run: |
          echo "Running production health checks..."
          # TODO: Implement production health check
          # ssh prod-server "/usr/local/bin/nwp-healthcheck.sh prod ${{ secrets.PRODUCTION_URL }}"

      - name: Rollback on failure
        if: failure() && steps.deploy.outputs.deploy_success == 'true'
        run: |
          echo "Deployment or health checks failed, initiating rollback..."
          # TODO: Trigger rollback
          # ssh prod-server "/usr/local/bin/nwp-rollback.sh"

      - name: Log deployment audit
        if: steps.deploy.outputs.deploy_success == 'true'
        run: |
          echo "Logging deployment to audit trail..."
          # TODO: Log to audit system
          # ssh prod-server "/usr/local/bin/nwp-audit.sh deploy_success ${{ env.SITE_NAME }}"

      - name: Notify deployment status
        if: always()
        run: |
          if [ -f scripts/notify.sh ]; then
            STATUS=${{ job.status }}
            EVENT="deploy_${STATUS}"
            ./scripts/notify.sh \
              --event=$EVENT \
              --site=${{ env.SITE_NAME }} \
              --url=${{ secrets.PRODUCTION_URL }}
          fi

      - name: Create deployment tag
        if: steps.deploy.outputs.deploy_success == 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          TAG="deploy-$(date +%Y%m%d-%H%M%S)"
          git tag -a "$TAG" -m "Production deployment: ${{ env.SITE_NAME }}"
          git push origin "$TAG" || echo "Failed to push tag"

  # Preview environment for pull requests
  deploy-preview:
    name: Deploy Preview Environment
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'pull_request'
    environment:
      name: preview/pr-${{ github.event.pull_request.number }}
      url: https://pr-${{ github.event.pull_request.number }}.ddev.site
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup DDEV
        uses: ddev/github-action-setup-ddev@v1
        with:
          autostart: false

      - name: Restore database cache
        uses: actions/cache/restore@v4
        with:
          path: .data/db.sql.gz
          key: db-nightly-
          restore-keys: |
            db-nightly-
            db-

      - name: Create preview environment
        id: preview
        run: |
          ./scripts/ci/create-preview.sh "pr-${{ github.event.pull_request.number }}"

      - name: Get preview URL
        id: get-url
        run: |
          if [ -f .preview-env ]; then
            source .preview-env
            echo "preview_url=$PREVIEW_URL" >> $GITHUB_OUTPUT
          else
            echo "preview_url=https://pr-${{ github.event.pull_request.number }}.ddev.site" >> $GITHUB_OUTPUT
          fi

      - name: Comment PR with preview URL
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.get-url.outputs.preview_url }}';
            const body = `## Preview Environment Ready

            Your preview environment is ready for testing:

            **Preview URL:** ${url}

            ### What's included:
            - Latest code from this PR
            - Sanitized production database
            - Isolated DDEV environment

            ### Notes:
            - This environment will be automatically cleaned up when the PR is closed
            - The environment will auto-stop after 1 week of inactivity
            - You can manually trigger cleanup from the Actions tab if needed

            Happy testing! ðŸš€`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Save preview metadata
        uses: actions/upload-artifact@v4
        with:
          name: preview-env-pr-${{ github.event.pull_request.number }}
          path: .preview-env
          retention-days: 7

  # Cleanup preview when PR is closed
  cleanup-preview:
    name: Cleanup Preview Environment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup DDEV
        uses: ddev/github-action-setup-ddev@v1
        with:
          autostart: false

      - name: Cleanup preview environment
        run: |
          ./scripts/ci/cleanup-preview.sh "pr-${{ github.event.pull_request.number }}" || true

      - name: Comment PR with cleanup status
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## Preview Environment Cleaned Up\n\nThe preview environment for this PR has been successfully removed.'
            });
