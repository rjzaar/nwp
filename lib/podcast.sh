#!/bin/bash

################################################################################
# Podcast Helper Functions
#
# Provides high-level functions for podcast hosting setup using Castopod
# Orchestrates Linode, Cloudflare, and B2 for complete podcast infrastructure
#
# Requirements:
# - lib/linode.sh, lib/cloudflare.sh, lib/b2.sh sourced
# - All credentials configured in .secrets.yml
################################################################################

PODCAST_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source required libraries if not already loaded
[ -z "${LINODE_LIB_LOADED:-}" ] && source "$PODCAST_LIB_DIR/linode.sh" && LINODE_LIB_LOADED=1
[ -z "${CLOUDFLARE_LIB_LOADED:-}" ] && source "$PODCAST_LIB_DIR/cloudflare.sh" && CLOUDFLARE_LIB_LOADED=1
[ -z "${B2_LIB_LOADED:-}" ] && source "$PODCAST_LIB_DIR/b2.sh" && B2_LIB_LOADED=1

# Generate a secure random password
# Usage: generate_password [length]
generate_password() {
    local length=${1:-24}
    openssl rand -base64 48 | tr -d '/=+' | cut -c -"$length"
}

# Generate Castopod environment variables
# Usage: generate_castopod_env "domain" "db_password" "b2_key_id" "b2_app_key" "b2_bucket" "b2_region"
generate_castopod_env() {
    local domain=$1
    local db_password=$2
    local b2_key_id=$3
    local b2_app_key=$4
    local b2_bucket=$5
    local b2_region=${6:-us-west-004}

    cat << EOF
# Castopod Environment Configuration
# Generated by NWP Podcast Setup

# Application
CP_BASEURL="https://${domain}"
CP_ADMIN_GATEWAY="admin"
CP_AUTH_GATEWAY="auth"

# Database
CP_DATABASE_HOSTNAME="mariadb"
CP_DATABASE_NAME="castopod"
CP_DATABASE_USERNAME="castopod"
CP_DATABASE_PASSWORD="${db_password}"
CP_DATABASE_PREFIX="cp_"

# Cache & Sessions
CP_CACHE_HANDLER="redis"
CP_REDIS_HOST="redis"
CP_REDIS_PORT="6379"

# Media Storage (Backblaze B2)
CP_MEDIA_BASE_URL="https://media.${domain#*.}"
CP_MEDIA_STORAGE_TYPE="s3"
CP_MEDIA_S3_ENDPOINT="https://s3.${b2_region}.backblazeb2.com"
CP_MEDIA_S3_KEY="${b2_key_id}"
CP_MEDIA_S3_SECRET="${b2_app_key}"
CP_MEDIA_S3_BUCKET="${b2_bucket}"
CP_MEDIA_S3_REGION="${b2_region}"

# Email (configure as needed)
# CP_EMAIL_FROM="podcast@${domain#*.}"
# CP_EMAIL_SMTP_HOST=""
# CP_EMAIL_SMTP_USERNAME=""
# CP_EMAIL_SMTP_PASSWORD=""
# CP_EMAIL_SMTP_PORT="587"
# CP_EMAIL_SMTP_CRYPTO="tls"

# Analytics
CP_ENABLE_2_WAY_SYNC="true"

# Performance
CP_MAX_BODY_SIZE="512M"
PHP_MEMORY_LIMIT="512M"
PHP_MAX_EXECUTION_TIME="300"
EOF
}

# Generate docker-compose.yml for Castopod
# Usage: generate_castopod_compose "domain"
generate_castopod_compose() {
    local domain=$1

    cat << 'EOF'
version: "3.9"

services:
  castopod:
    image: castopod/castopod:latest
    container_name: castopod-app
    restart: unless-stopped
    volumes:
      - castopod-media:/var/www/castopod/public/media
    environment:
      - CP_BASEURL
      - CP_ADMIN_GATEWAY
      - CP_AUTH_GATEWAY
      - CP_DATABASE_HOSTNAME
      - CP_DATABASE_NAME
      - CP_DATABASE_USERNAME
      - CP_DATABASE_PASSWORD
      - CP_DATABASE_PREFIX
      - CP_CACHE_HANDLER
      - CP_REDIS_HOST
      - CP_REDIS_PORT
      - CP_MEDIA_BASE_URL
      - CP_MEDIA_STORAGE_TYPE
      - CP_MEDIA_S3_ENDPOINT
      - CP_MEDIA_S3_KEY
      - CP_MEDIA_S3_SECRET
      - CP_MEDIA_S3_BUCKET
      - CP_MEDIA_S3_REGION
      - CP_MAX_BODY_SIZE
      - PHP_MEMORY_LIMIT
      - PHP_MAX_EXECUTION_TIME
    depends_on:
      - mariadb
      - redis
    networks:
      - castopod-net

  mariadb:
    image: mariadb:10.11
    container_name: castopod-db
    restart: unless-stopped
    volumes:
      - castopod-db:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=${CP_DATABASE_PASSWORD}
      - MYSQL_DATABASE=${CP_DATABASE_NAME:-castopod}
      - MYSQL_USER=${CP_DATABASE_USERNAME:-castopod}
      - MYSQL_PASSWORD=${CP_DATABASE_PASSWORD}
    networks:
      - castopod-net

  redis:
    image: redis:7-alpine
    container_name: castopod-redis
    restart: unless-stopped
    volumes:
      - castopod-redis:/data
    networks:
      - castopod-net

  caddy:
    image: caddy:2-alpine
    container_name: castopod-caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy-data:/data
      - caddy-config:/config
    depends_on:
      - castopod
    networks:
      - castopod-net

volumes:
  castopod-media:
  castopod-db:
  castopod-redis:
  caddy-data:
  caddy-config:

networks:
  castopod-net:
    driver: bridge
EOF
}

# Generate Caddyfile for Castopod
# Usage: generate_caddyfile "domain" "admin_email"
generate_caddyfile() {
    local domain=$1
    local admin_email=${2:-admin@${domain#*.}}

    cat << EOF
{
    email ${admin_email}
}

${domain} {
    reverse_proxy castopod:8000

    # Handle large uploads
    request_body {
        max_size 512MB
    }

    # Security headers
    header {
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        Referrer-Policy "strict-origin-when-cross-origin"
    }

    # Gzip compression
    encode gzip

    # Logging
    log {
        output file /var/log/caddy/access.log
    }
}
EOF
}

# Generate complete podcast setup files
# Usage: generate_podcast_files "output_dir" "domain" "admin_email" "b2_key_id" "b2_app_key" "b2_bucket" "b2_region"
generate_podcast_files() {
    local output_dir=$1
    local domain=$2
    local admin_email=$3
    local b2_key_id=$4
    local b2_app_key=$5
    local b2_bucket=$6
    local b2_region=${7:-us-west-004}

    # Generate DB password
    local db_password=$(generate_password 24)

    # Create output directory
    mkdir -p "$output_dir"

    # Generate .env file
    generate_castopod_env "$domain" "$db_password" "$b2_key_id" "$b2_app_key" "$b2_bucket" "$b2_region" > "$output_dir/.env"

    # Generate docker-compose.yml
    generate_castopod_compose "$domain" > "$output_dir/docker-compose.yml"

    # Generate Caddyfile
    generate_caddyfile "$domain" "$admin_email" > "$output_dir/Caddyfile"

    # Generate deploy script
    cat > "$output_dir/deploy.sh" << 'DEPLOY'
#!/bin/bash
set -euo pipefail

echo "Deploying Castopod..."

# Load environment
set -a
source .env
set +a

# Pull latest images
docker compose pull

# Start services
docker compose up -d

# Wait for services
echo "Waiting for services to start..."
sleep 10

# Check status
docker compose ps

echo ""
echo "Castopod is starting up!"
echo "Visit https://${CP_BASEURL#https://} to complete setup"
echo ""
echo "First-time setup:"
echo "  1. Create an admin account at https://${CP_BASEURL#https://}/admin/install"
echo "  2. Create your first podcast"
echo "  3. Configure podcast settings"
DEPLOY
    chmod +x "$output_dir/deploy.sh"

    echo "Podcast files generated in: $output_dir" >&2
    echo "  - .env (environment configuration)"
    echo "  - docker-compose.yml (container setup)"
    echo "  - Caddyfile (reverse proxy)"
    echo "  - deploy.sh (deployment script)"
}

# Setup complete podcast infrastructure
# Usage: setup_podcast_infrastructure "domain" "media_subdomain" "linode_region" "script_dir"
# Returns: JSON-like output with all created resources
setup_podcast_infrastructure() {
    local domain=$1
    local media_subdomain=${2:-media}
    local linode_region=${3:-us-east}
    local script_dir=${4:-.}

    echo "Setting up podcast infrastructure for $domain" >&2

    # Get credentials
    local linode_token=$(get_linode_token "$script_dir")
    local cf_token=$(get_cloudflare_token "$script_dir")
    local cf_zone_id=$(get_cloudflare_zone_id "$script_dir")

    # Validate credentials
    if [ -z "$linode_token" ]; then
        echo "ERROR: Linode API token not found" >&2
        return 1
    fi
    if [ -z "$cf_token" ] || [ -z "$cf_zone_id" ]; then
        echo "ERROR: Cloudflare credentials not found" >&2
        return 1
    fi
    if ! b2_check_auth; then
        echo "ERROR: B2 not authenticated" >&2
        return 1
    fi

    # Verify Cloudflare auth
    if ! verify_cloudflare_auth "$cf_token" "$cf_zone_id"; then
        return 1
    fi

    local results=""
    local base_domain="${domain#*.}"
    local podcast_subdomain="${domain%%.*}"

    # 1. Create B2 bucket
    echo "" >&2
    echo "[1/4] Creating B2 bucket..." >&2
    local bucket_name="${podcast_subdomain}-media"
    local bucket_id=$(b2_create_bucket "$bucket_name" "allPublic")
    if [ -z "$bucket_id" ]; then
        echo "ERROR: Failed to create B2 bucket" >&2
        return 1
    fi
    results="${results}b2_bucket_id=$bucket_id\n"

    # Enable CORS
    b2_enable_cors "$bucket_name" "*" >/dev/null 2>&1 || true

    # Create application key for bucket
    local key_output=$(b2_create_app_key "$bucket_name" "${podcast_subdomain}-castopod")
    local b2_key_id=$(echo "$key_output" | awk '{print $1}')
    local b2_app_key=$(echo "$key_output" | awk '{print $2}')
    results="${results}b2_key_id=$b2_key_id\n"

    # 2. Create Linode instance
    echo "" >&2
    echo "[2/4] Creating Linode instance..." >&2
    local ssh_key_path="$script_dir/keys/nwp.pub"
    if [ ! -f "$ssh_key_path" ]; then
        ssh_key_path="$HOME/.ssh/nwp.pub"
    fi
    if [ ! -f "$ssh_key_path" ]; then
        echo "ERROR: SSH public key not found" >&2
        return 1
    fi

    local provision_result=$(provision_test_linode "$linode_token" "podcast-${podcast_subdomain}" "$ssh_key_path")
    local linode_id=$(echo "$provision_result" | awk '{print $1}')
    local server_ip=$(echo "$provision_result" | awk '{print $2}')

    if [ -z "$linode_id" ] || [ -z "$server_ip" ]; then
        echo "ERROR: Failed to create Linode instance" >&2
        return 1
    fi
    results="${results}linode_id=$linode_id\n"
    results="${results}server_ip=$server_ip\n"

    # 3. Create Cloudflare DNS records
    echo "" >&2
    echo "[3/4] Creating Cloudflare DNS records..." >&2

    # Podcast domain -> server
    local podcast_record=$(cf_upsert_dns_a "$cf_token" "$cf_zone_id" "$domain" "$server_ip" "true")
    results="${results}dns_podcast_record=$podcast_record\n"

    # Media subdomain -> B2 (CNAME to friendly URL would need Cloudflare Workers for B2)
    # For now, point to server which can proxy or redirect
    local media_domain="${media_subdomain}.${base_domain}"
    local media_record=$(cf_upsert_dns_a "$cf_token" "$cf_zone_id" "$media_domain" "$server_ip" "true")
    results="${results}dns_media_record=$media_record\n"

    # 4. Generate configuration files
    echo "" >&2
    echo "[4/4] Generating configuration files..." >&2
    local output_dir="$script_dir/podcast-setup-$(date +%Y%m%d-%H%M%S)"
    local b2_region="us-west-004"  # Default, adjust as needed

    generate_podcast_files "$output_dir" "$domain" "admin@${base_domain}" \
        "$b2_key_id" "$b2_app_key" "$bucket_name" "$b2_region"

    results="${results}output_dir=$output_dir\n"

    # Generate deployment script
    cat > "$output_dir/deploy-to-server.sh" << DEPLOY
#!/bin/bash
set -euo pipefail

SERVER_IP="${server_ip}"
SSH_KEY="${ssh_key_path%.pub}"

echo "Deploying Castopod to \$SERVER_IP..."

# Copy files to server
scp -i "\$SSH_KEY" -r .env docker-compose.yml Caddyfile deploy.sh root@\$SERVER_IP:/root/castopod/

# Run deployment
ssh -i "\$SSH_KEY" root@\$SERVER_IP "cd /root/castopod && chmod +x deploy.sh && ./deploy.sh"

echo ""
echo "Deployment complete!"
echo "Visit https://${domain} to complete Castopod setup"
DEPLOY
    chmod +x "$output_dir/deploy-to-server.sh"

    echo "" >&2
    echo "========================================"  >&2
    echo "Podcast infrastructure setup complete!" >&2
    echo "========================================" >&2
    echo "" >&2
    echo "Resources created:" >&2
    echo "  Linode ID: $linode_id" >&2
    echo "  Server IP: $server_ip" >&2
    echo "  B2 Bucket: $bucket_name" >&2
    echo "  DNS: $domain -> $server_ip" >&2
    echo "  DNS: $media_domain -> $server_ip" >&2
    echo "" >&2
    echo "Configuration files: $output_dir" >&2
    echo "" >&2
    echo "Next steps:" >&2
    echo "  1. cd $output_dir" >&2
    echo "  2. ./deploy-to-server.sh" >&2
    echo "" >&2

    echo -e "$results"
}

# Teardown podcast infrastructure
# Usage: teardown_podcast "linode_id" "bucket_name" "dns_records..." "script_dir"
teardown_podcast() {
    local linode_id=$1
    local bucket_name=$2
    local script_dir=${3:-.}
    shift 3
    local dns_records=("$@")

    local linode_token=$(get_linode_token "$script_dir")
    local cf_token=$(get_cloudflare_token "$script_dir")
    local cf_zone_id=$(get_cloudflare_zone_id "$script_dir")

    echo "Tearing down podcast infrastructure..." >&2

    # Delete Linode
    if [ -n "$linode_id" ] && [ -n "$linode_token" ]; then
        echo "Deleting Linode instance $linode_id..." >&2
        delete_linode_instance "$linode_token" "$linode_id"
    fi

    # Delete B2 bucket (must be empty)
    if [ -n "$bucket_name" ]; then
        echo "Deleting B2 bucket $bucket_name..." >&2
        b2_delete_bucket "$bucket_name" 2>/dev/null || echo "Note: Bucket may not be empty" >&2
    fi

    # Delete DNS records
    if [ -n "$cf_token" ] && [ -n "$cf_zone_id" ]; then
        for record_id in "${dns_records[@]}"; do
            if [ -n "$record_id" ]; then
                echo "Deleting DNS record $record_id..." >&2
                cf_delete_dns_record "$cf_token" "$cf_zone_id" "$record_id"
            fi
        done
    fi

    echo "Teardown complete" >&2
}

# Export functions
export -f generate_password
export -f generate_castopod_env
export -f generate_castopod_compose
export -f generate_caddyfile
export -f generate_podcast_files
export -f setup_podcast_infrastructure
export -f teardown_podcast
